defmodule Int do
  import Algae

  defdata do
    int :: integer()
  end

  # def new() do
  #   super()
  #   raise(UndefinedFunctionError, "Int.new/0 is undefined or private")
  # end

  def new(int) when is_integer(int) do
    super(int)
  end

  def new(_), do: raise(ArgumentError, "not int")
end

# iex(4)> defmodule A do
# ...(4)>   defmacro lofa() do
# ...(4)>     args = Macro.generate_arguments(2, __MODULE__)
# ...(4)>     quote do
# ...(4)>        def miez(unquote_splicing(args)), do: :works
# ...(4)>     end
# ...(4)>   end
# ...(4)> end
# warning: redefining module A (current version defined in memory)
#   iex:4

# {:module, A,
#  <<70, 79, 82, 49, 0, 0, 5, 48, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 185,
#    0, 0, 0, 19, 8, 69, 108, 105, 120, 105, 114, 46, 65, 8, 95, 95, 105, 110,
#    102, 111, 95, 95, 7, 99, 111, 109, 112, ...>>, {:lofa, 0}}
# iex(5)> defmodule B do
# ...(5)> import A
# ...(5)> lofa()
# ...(5)> end
# {:module, B,
#  <<70, 79, 82, 49, 0, 0, 4, 0, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 126, 0,
#    0, 0, 14, 8, 69, 108, 105, 120, 105, 114, 46, 66, 8, 95, 95, 105, 110, 102,
#    111, 95, 95, 7, 99, 111, 109, 112, ...>>, {:miez, 2}}
# iex(6)> B.miez
# miez/2
# iex(6)> B.miez(1,2)

  # def new(), do: fn(a)    -> apply(__MODULE__, :new, [a]) end
  # def new(a), do: fn(b)   -> apply(__MODULE__, :new, [a, b]) end
  # def new(a,b), do: fn(c) -> apply(__MODULE__, :new, [a, b, c]) end
  # def new(a, b, c), do: a - b - c
  #
  # defmodule A do
  #   def new(),    do: fn(a) -> Person.newp(a)   end
  #   def new(a),   do: fn(b) -> Person.newp(a,b) end
  #   def new(a,b), do: Person.newp(a,b)
  # end
defmodule A do
  defmacro lofa() do
    args = Macro.generate_arguments(3, __MODULE__)
    IO.inspect(args)

    scanned_args =
      [[]] ++ Enum.scan(args, [], &(&2 ++ [&1]))

    quote do
      use Quark

      defpartialx lofa(a,b,c), do: a-b-c

      # unquote do:  make_tracking_clauses(scanned_args)
      unquote do: Enum.map(
        scanned_args,
        fn(a) ->
          IO.inspect(length(a) == 3)
            # def miez(unquote_splicing(a)), do: :works
          case length(a) == 3 do
            false ->
              quote do
                def miez(unquote_splicing(a)) do
                  fn(curried) ->
                    apply(__MODULE__, :lofa, unquote(a))
                    # lofa(unquote_splicing(a))
                  end
                end
              end
            true ->
              quote do
                def miez(unquote_splicing(a)) do
                  apply(__MODULE__, :lofa, unquote(a))
                end
              end
          end
        end)
    end
  end

  defp make_tracking_clauses([track_args, next_args|[]]) do
    quote do
      def unquote({:miez, [], track_args}) do
      # def miez(unquote_splicing(track_args)) do
        lofa(unquote_splicing(track_args))
      end
    end
  end

  defp make_tracking_clauses([track_args, next_args|rest]) do
    quote do
      # def miez(unquote_splicing(track_args)) do
      def unquote({:miez, [], track_args}) do
        fn(curried) -> lofa(unquote_splicing(next_args)) end
      end
      unquote do: make_tracking_clauses(rest)
    end
  end

end

defmodule B do
  import A
  lofa()
end

# ------------------------------

defmodule BinaryId do
  import Algae

  defdatax do
    binary_id :: binary
  end

  def new() do
    Ecto.UUID.generate()
    |> new()
  end

  def type(%__MODULE__{binary_id: binary_id}) do
    Ecto.UUID.cast!(binary_id)
  end
end

defmodule User do
  import Algae

  defdatax do
    user_id :: BinaryId
    name    :: string
  end
end

# ------------------------------

defmodule Person do
  import Algae
  defdatax do
  # defdatax overrides: ["new/1": fn(name) -> IO.puts("WORKS: #{name}") end] do
  # defdatax overrides: ["new/1": fn(_) -> raise(UndefinedFunctionError, "locked") end] do
  # defdatax overrides: ["new/2": fn(name, age) -> IO.puts("WORKS: #{name} #{age}"); ["miez", 7] end] do
  # defdatax overrides: ["new/1": fn(name) -> IO.puts("WORKS: #{name}") end, "new/2": fn(a,b) -> IO.puts("WORKS #{a} #{b}") end] do
    name :: string
    age  :: integer
  end

  # def new(name), do: raise(UndefinedFunctionError, "lofa")
end
Person.new
Person.new("lofa")
Person.new("lofa", 27)
Person.new("lofa").(27)
Person.new.("lofa").(27)
[
  overrides: [
    "new/1": {:fn, [line: 3],
     [
       {:->, [line: 3],
        [
          [{:name, [line: 3], nil}],
          {{:., [line: 3], [{:__aliases__, [line: 3], [:IO]}, :inspect]},
           [line: 3], [{:name, [line: 3], nil}]}
        ]}
     ]}
  ]
]
[
  do: {:__block__, [],
   [
     {:::, [line: 4], [{:name, [line: 4], nil}, {:string, [line: 4], nil}]},
     {:::, [line: 5], [{:age, [line: 5], nil}, {:integer, [line: 5], nil}]}
   ]}
]
  # def new(str) do
  #   apply(Algae.Prim, :string, [str])
  #   super(str)
  # end

  # def new(str, int) do
  #   apply(Algae.Prim, :string, [str])
  #   apply(Algae.Prim, :integer, [int])
  #   super(str, int)
  # end

defmodule Employee do
  import Algae
  defdatax do
    person :: Person
    role :: string
  end
end

def mod(num, denom) do
  inter = rem(num, denom)
  if inter < 0 do denom + inter else denom end
end

defdata Clock do
  hour: mod(integer, 24)
  minute: mod(integer, 60)
end

five_minutes = %Clock{hour: -1, minute: 55}
# => %Clock{hour: 23, minute: 55}

%five_minutes{minute: 102}
# => Clock[hour: 23, minute: 42]

[
  hour: {:__aliases__, [line: 5], [:Hour]},
  minute: {:__aliases__, [line: 6], [:Minute]}
]

{:minute, {:__aliases__, [line: 45], [:Clock, :Minute]}}

defmodule Clock do
  import Algae

  defdatax do
    hour :: Clock.Hour
    minute :: Clock.Minute
  end

  def new(minutes) do
    mins = rem(minutes, 60)
    hours = div(minutes, 60)
    new(hours, minutes)
  end

  def new(hours, minutes) do
    h = Clock.Hour.new(hours)
    m = Clock.Minute.new(minutes)
    super(h,m)
  end

  def mod(num, denom) do
    inter = rem(num, denom)
    if inter < 0 do denom + inter else inter end
  end

  defmodule Hour do
    defdatax do
      hour :: integer
    end

    def new(hour) do
      hour
      |> Clock.mod(24)
      |> super()
    end
  end

  defmodule Minute do
    defdatax do
      minute :: integer
    end

    def new(minute) do
      minute
      |> Clock.mod(60)
      |> super()
    end
  end
end

# =======================================

defmodule Hour do
  import Algae
  defdatax do
    hour :: integer
  end

  def new(hour) do
    hour
    |> Clock.mod(24)
    |> super()
  end
end

defmodule Minute do
  import Algae
  defdatax do
    minute :: integer
  end

  def new(minute) do
    minute
    |> Clock.mod(60)
    |> super()
  end
end

defmodule Clock do
  import Algae

  defdatax do
    hour :: Hour
    minute :: Minute
  end

  def new(hour, minute) do
    h = Hour.new(hour)
    m = Minute.new(minute)
    super(h,m)
  end

  def mod(num, denom) do
    inter = rem(num, denom)
    if inter < 0 do denom + inter else inter end
  end
end

pry(2)> lines
[
  {:::, [line: 5], [{:hour, [line: 5], nil}, {:__aliases__, [line: 5], [:Hour]}]},
  {:::, [line: 6], [{:minute, [line: 6], nil}, {:__aliases__, [line: 6], [:Minute]}]}

pry(1)> lines
[
  {:::, [line: 7], [{:hour, [line: 7], nil}, {:__aliases__, [line: 7], [:Clock, :Hour]}]},
  {:::, [line: 8], [{:minute, [line: 8], nil}, {:__aliases__, [line: 8], [:Clock, :Minute]}]}
]

# =============================

defdata AcuteTriangle, validate: acute do
  angle1: float
  angle2: float
end

defp acute(%AcuteTriangle{angle1: angle1, angle2: angle2}) do: abs(angle1 - angle2) < 90.0

# ---

defmodule AcuteTriangle do
  import Algae
  defdatax do
    angle1 :: float
    angle2 :: float
  end

  def new(alfa, beta) do
    case abs(alfa - beta) < 90.0 do
      false ->
        # super(alfa, beta)
        raise(ArgumentError, "angles are not acute")
      true ->
        super(alfa, beta)
    end
  end
end
